% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/band.R
\name{band}
\alias{band}
\title{Simultaneous Bands for Functional Data}
\usage{
band(
  data,
  type = c("prediction", "confidence"),
  alpha = 0.05,
  iid = TRUE,
  id = NULL,
  B = 1000L
)
}
\arguments{
\item{data}{Numeric matrix with T rows (time) and n columns (curves).
A data.frame of numeric columns is also accepted and coerced to a matrix.}

\item{type}{Character, either "prediction" or "confidence".}

\item{alpha}{Numeric in (0, 1). Use 0.05 for 95\% bands.}

\item{iid}{Logical; if FALSE, use a cluster bootstrap (requires \code{id} or
infers clusters from column-name prefixes).}

\item{id}{Optional integer/factor vector of length ncol(data) giving a cluster id
for each curve (used when \code{iid = FALSE}). If NULL and \code{iid = FALSE}, clusters
are inferred from column names by prefix (up to the first underscore, hyphen, or dot).}

\item{B}{Integer, number of bootstrap iterations (e.g., 1000 for final results;
use smaller values in examples/tests).}
}
\value{
A list with elements \code{lower}, \code{mean}, \code{upper} (each of length T) and \code{meta}
(a list with settings such as type, alpha, iid, B, n, T).
}
\description{
Create simultaneous bootstrap bands for dense functional data
(rows are time points, columns are curves). Supports clustered designs
via a simple cluster bootstrap when \code{iid = FALSE}.
}
\examples{
\donttest{
## i.i.d. example with shaded band
set.seed(1)
T <- 40; n <- 12
Y <- matrix(rnorm(T * n, sd = 0.3), nrow = T, ncol = n)
fit <- band(Y, type = "prediction", alpha = 0.1, iid = TRUE, B = 50)
x <- seq_len(fit$meta$T)
plot(x, fit$mean, type = "n", ylim = range(c(fit$lower, fit$upper)),
     xlab = "Index", ylab = "Value", main = "Prediction band")
polygon(c(x, rev(x)), c(fit$lower, rev(fit$upper)),
        col = grDevices::adjustcolor("steelblue", alpha.f = 0.3), border = NA)
lines(x, fit$mean, lwd = 2)
lines(x, fit$lower, lty = 2)
lines(x, fit$upper, lty = 2)

## hierarchical example with clustered curves
set.seed(2)
T  <- 60; m <- c(8, 7, 6); K <- length(m)
t  <- seq(0, 1, length.out = T)
mu <- list(
  function(x) 0.8 * sin(2*pi*x) + 0.2,
  function(x) 0.5 * cos(2*pi*x) - 0.1,
  function(x) 0.6 * sin(4*pi*x)
)
Bm <- cbind(sin(2*pi*t), cos(2*pi*t), sin(4*pi*t))
gen_curve <- function(k) {
  sc <- rnorm(ncol(Bm), sd = c(0.25, 0.18, 0.12))
  mu[[k]](t) + as.vector(Bm \%*\% sc) + rnorm(T, sd = 0.15)
}
Ylist <- lapply(seq_len(K), function(k) sapply(seq_len(m[k]), function(i) gen_curve(k)))
Yh    <- do.call(cbind, Ylist)
id    <- rep(seq_len(K), times = m)
fitH  <- band(Yh, type = "prediction", alpha = 0.1, iid = FALSE, id = id, B = 60)

# plot: gray raw curves, shaded band, black mean, colored cluster means
xh    <- seq_len(fitH$meta$T)
ylimH <- range(c(Yh, fitH$lower, fitH$upper), finite = TRUE)
plot(xh, fitH$mean, type = "n", xlab = "Index", ylab = "Value",
     ylim = ylimH, main = "Prediction band with clustered curves")
matlines(xh, Yh, lty = 1, col = grDevices::adjustcolor("gray40", alpha.f = 0.4))
polygon(c(xh, rev(xh)), c(fitH$lower, rev(fitH$upper)),
        col = grDevices::adjustcolor("steelblue", alpha.f = 0.30), border = NA)
lines(xh, fitH$mean,  lwd = 2)
lines(xh, fitH$lower, lty = 2)
lines(xh, fitH$upper, lty = 2)
cl_cols <- c("firebrick", "darkgreen", "navy")
for (k in seq_len(K)) {
  cl_mean <- rowMeans(Yh[, id == k, drop = FALSE])
  lines(xh, cl_mean, lwd = 2, col = cl_cols[k])
}
legend("topleft", bty = "n",
       legend = paste("Cluster", seq_len(K)),
       lwd = 2, col = cl_cols)
}

}
